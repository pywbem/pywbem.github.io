<!DOCTYPE html>
<html>
<head>
<base href="..">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="robots" content="index, follow">
<meta name="description" content="This site provides documentation for the PyWBEM projects on GitHub.">
<title>PyWBEM Client - Tutorial</title>
<link rel="stylesheet" href="resources/style.css" type="text/css">
</head>
<body>
<script src="resources/jquery.js"></script>
<script src="resources/script.js"></script>
<h1 align="center">PyWBEM Client - Tutorial</h1>
<div id="header_html"></div>
<script type="text/javascript">
  load_url_into_id('header.html', 'header_html');
</script>
<div id="navbar_html"></div>
<script type="text/javascript">
  load_url_into_id('navbar.html', 'navbar_html');
</script>

<div id="content">

<h2>Tutorial</h2>

<p>This is a short tutorial about using the PyWBEM client library. It is
intended to be enough to get people who know a bit about WBEM and CIM up and
going.</p>

<p>Python code in this tutorial is shown using the interactive Python
interpreter. The examples are meant to be run in order. The interpreter is
started up like this:</p>

<blockquote><pre>$ python
Python 2.6.6 (r266:84292, May 22 2015, 08:34:51)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-15)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>
</pre></blockquote>

<p>The output of running the various examples has been reformatted for
readability.</p>

<h3>Making Connections</h3>

<p>Once PyWBEM has been <a href="pywbem/installation.html">installed</a>,
the next stage is to learn how to make connections to WBEM servers. A client's
connection to a WBEM server is represented by an instance of the
<script>doc_link('class', 'pywbem.cim_operations.WBEMConnection',
                 'WBEMConnection')</script>
Python class.</p>

<p>Creating a connection is quite simple. All that is required is a URL for the
WBEM server, and a set of credentials.  The following code fragment creates an
SSL-encrypted connection to <tt>wbem.example.com</tt> using a dummy user and
dummy password:</p>

<blockquote><pre>>>> import pywbem
>>> conn = pywbem.WBEMConnection('https://wbem.example.com',
                                 ('user', 'password'))
</pre></blockquote>

<p>After creating a connection, various methods may be called on the
<tt>WBEMConnection</tt> object, which causes remote calls to the WBEM
server.</p>

<p>As usual in HTTP, there is no persistent TCP connection; the connectedness
provided by this class is  only conceptual. That is, the creation of the
connection object does not cause any interaction with the WBEM server, and
each subsequent operation performs an independent, state-less HTTP/HTTPS
request, setting up and tearing down a new TCP connection.</p>

<h3>Python Object and Data Model</h3>

<p>One of the goals of PyWBEM is to have an understandable, well-integrated,
and easy to use interface to CIM objects and operations. This is achieved by the
thoughtful mapping of CIM objects such as instances, instance names, properties,
classes, etc. to Python objects. There is no need to worry about the
representation of CIM objects in XML, or anything related to HTTP/HTTPS.</p>

<p>PyWBEM represents CIM objects in a generic way. For example, CIM instances
are represented as objects of the Python class <tt>CIMInstance</tt>, and CIM
classes as objects of the Python class <tt>CIMClass</tt>. Thus, a CIM instance
of class "CIM_Person" is represented as a Python object of type
<tt>CIMInstance</tt> whose <tt>classname</tt> attribute is set to
"CIM_Person".</p>

<p>This approach is simple and straight forward. However, first-class object
aficionados might prefer Python objects of type <tt>CIM_Person</tt> for CIM
instances of class "CIM_Person", instead. Such a first-class object
representation has its own complexities, however, and is not currently
supported by PyWBEM.</p>

<h4>CIM Instances and Instance Names</h4>

<p>The two fundamental Python classes in PyWBEM are
<script>doc_link('class', 'pywbem.cim_obj.CIMInstance',
                 'CIMInstance')</script> and
<script>doc_link('class', 'pywbem.cim_obj.CIMInstanceName',
                 'CIMInstanceName')</script>.
A <tt>CIMInstance</tt> object is a representation of
a CIM instance in a WBEM server, which in turn represents a physical or logical
resource that is under management, or an aspect thereof. Examples for such
resources are disk drives, temperature sensors, or network cards. The most
interesting part of a CIM instance is the properties and values those
properties take. The properties of a <tt>CIMInstance</tt> object can be
accessed by treating the object as a Python dictionary:</p>

<blockquote><pre>>>> from pywbem import CIMInstance
>>> i = CIMInstance('CIM_Person')
>>> i['Firstname'] = 'Tim'
>>> i['Lastname'] = 'Potter'
>>> print i.items()
[('Lastname', 'Potter'), ('Firstname', 'Tim')]
</pre></blockquote>

<p>A <tt>CIMInstanceName</tt> object is a reference to a CIM instance in a
WBEM server. It may specify the location of the WBEM server, the CIM namespace
within the server, the CIM class within the namespace, and identifies the CIM
instance within the class by means of its key property values. These key
property values are called <i>key bindings</i> in CIM.</p>

<p>The key bindings of a <tt>CIMInstanceName</tt> object can also be
accessed by treating the object as a Python dictionary.</p>

<h4>CIM Data Types</h4>

<p>CIM has a number of data types that are mostly mapped to specific Python
classes, and in some cases to built-in Python types such as <tt>bool</tt>,
<tt>str</tt>/<tt>unicode</tt> or <tt>list</tt>.</p>

<p>See the
<script>doc_link('module', 'pywbem.cim_types', 'cim_types')</script>
module for details about the mapping.</p>

<h3>CIM Instance Operations</h3>

<p>PyWBEM supports all CIM operations to query, access and manipulate CIM
instances. These CIM operations are all methods of the <tt>WBEMConnection</tt>
class, and take Python CIM objects as parameters and return Python CIM objects
as results.</p>

<h4>EnumerateInstances</h4>

<p>The
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.EnumerateInstances',
                 'EnumerateInstances()')</script>
method returns a list of
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstance',
                 'CIMInstance')</script>
objects for each instance of a particular CIM class (and its subclasses). The
instance path is part of the return objects and can be accessed via the
<tt>path</tt> attribute.</p>

<p>The following script fetches the CIM instances for every process running on
the managed node and displays all the details for the first process
returned:</p>

<blockquote><pre>>>> processes = conn.EnumerateInstances('CIM_Process')
>>> print processes[0].items()
[(u'Parameters', [u'init']),
 (u'CSName', u'nautilus3.asiapacific.cpqcorp.net'),
 (u'RealUserID', 0L),
 (u'OSName', u'Red Hat Enterprise Linux AS'),
 (u'Priority', 15L),
 (u'OtherExecutionDescription', None),
 (u'ProcessNiceValue', 0L),
 (u'Handle', u'1'),
 (u'Description', u'init'),
 (u'OSCreationClassName', u'CIM_OperatingSystem'),
 (u'WorkingSetSize', 0L),
 (u'Name', u'init'),
 (u'ProcessGroupID', 0L),
 (u'ProcessTTY', u'?'),
 (u'Caption', u'init'),
 (u'ProcessSessionID', 0L),
 (u'KernelModeTime', 7651000L),
 (u'ParentProcessID', u'0'),
 (u'ExecutionState', 6L),
 (u'CSCreationClassName', u'CIM_UnitaryComputerSystem'),
 (u'UserModeTime', 1000L),
 (u'CreationClassName', u'PG_UnixProcess')]
</pre></blockquote>

<h4>EnumerateInstanceNames</h4>

<p>The
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.EnumerateInstanceNames',
                 'EnumerateInstanceNames()')</script>
method returns a list of
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstanceName',
                 'CIMInstanceName')</script>
objects which are the instance paths of each instance of a particular CIM class
(and its subclasses).  We can perform a similar operation on the list of
processes on the managed node as for <tt>EnumerateInstances()</tt> above:</p>

<blockquote><pre>>>> process_names = conn.EnumerateInstanceNames('CIM_Process')
>>> print process_names[0].items()
[(u'CSName', u'nautilus3.asiapacific.cpqcorp.net'),
 (u'Handle', u'1'),
 (u'OSCreationClassName', u'CIM_OperatingSystem'),
 (u'CreationClassName', u'PG_UnixProcess'),
 (u'CSCreationClassName', u'CIM_UnitaryComputerSystem'),
 (u'OSName', u'Red Hat Enterprise Linux AS')]
</blockquote></pre>

<p>Note that you cannot necessarily assume that the ordering of the returned
results for the <tt>CIM_Process</tt> provider is the same for enumerating
instance names as it is for enumerating instances. We just happen to be lucky in
this case. Also note that the list of key bindings displayed for the instance
name is a subset of the list of properties displayed for the instance.</p>

<p>Instance names are required as parameters for most PyWBEM calls as
they uniquely identify a CIM instance on the managed node.</p>

<h4>GetInstance</h4>

<p>Calling
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.GetInstance',
                 'GetInstance()')</script>
returns a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstance',
                 'CIMInstance')</script>
object, given a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstanceName',
                 'CIMInstanceName')</script>
object that references the desired CIM instance:</p>

<blockquote><pre>>>> process0 = conn.GetInstance(process_names[0])
>>> process0 == processes[0]
True
</blockquote></pre>

<p>Again, we are relying on the assumption that the first element of the
<tt>CIM_Process</tt> instance names is the same as the
<tt>CIM_Process</tt> instances, which may or may not actually be the case.</p>

<h4>DeleteInstance</h4>

<p>For some CIM classes, deletion of the corresponding managed resources is
defined. This is typically not defined in the CIM Schema, but in WBEM Management
Profiles (see DMTF standard DSP1001). For some others, it makes no sense to do
so. Often, management profiles that define a semantics for the deletion of
managed resources, leave that optional for an implementation. The implementation
for a CIM class in the WBEM server (aka <i>CIM provider</i>) thus may or may not
support deletion of its instances.</p>

<p>The
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.DeleteInstance',
                 'DeleteInstance()')</script>
method takes a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstanceName',
                 'CIMInstanceName')</script>
object and deletes the referenced CIM instance, which in turn (dependent on the
CIM provider) deletes the CIM instance and the managed resource, or rejects the
operation.</p>

<blockquote><pre>>>> conn.DeleteInstance(process_names[0])
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File ".../pywbem/cim_operations.py", line 1142, in DeleteInstance
    self.imethodcall(
  File ".../pywbem/cim_operations.py", line 673, in imethodcall
    raise CIMError(code, tt[1]['DESCRIPTION'])
pywbem.cim_operations.CIMError: (7, u'CIM_ERR_NOT_SUPPORTED: The requested operation is not supported')
</pre></blockquote>

<p>As it turns out, the CIM provider of <tt>CIM_Process</tt> in our WBEM server
does not support the deletion of processes, so the WBEM server returns a failure
with CIM status <tt>CIM_ERR_NOT_SUPPORTED</tt>.</p>

<p>PyWBEM maps CIM operation failures to the Python exception
<script>doc_link('class',
                 'pywbem.cim_operations.CIMError',
                 'CIMError')</script>, and
raises an according exception in this case. The CIM status code is available as
a numeric value in the <tt>error_code</tt> attribute of the exception object,
and the
<script>doc_link('module',
                 'pywbem.cim_constants',
                 'cim_constants')</script>
module defines the CIM status code values.</p>

<h4>CreateInstance</h4>

<p>The creation of a CIM instance on a managed node and in turn the creation of
the underlying managed resource is achieved by calling the
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.CreateInstance',
                 'CreateInstance()')</script>
method. It takes a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstance',
                 'CIMInstance')</script>
object as input, which specifies the class and the initial properties for the
CIM instance to be created, and returns a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstanceName',
                 'CIMInstanceName')</script>
object that references the new CIM instance.</p>

<p>Like for <tt>DeleteInstance()</tt>, the CIM provider on the
WBEM server may or may not support the creation of new CIM instances.</p>

<h4>ModifyInstance</h4>

<p>Existing CIM instances can be modified by having the values of properties
changed.  This is achieved using the
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.ModifyInstance',
                 'ModifyInstance()')</script>
method. It takes a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstance',
                 'CIMInstance')</script>
object as input, which references the CIM instance to be modified
with its <tt>path</tt> attribute, and specifies new values for the
properties.</p>

<p>The <tt>PropertyList</tt> input parameter of the method specifies the names
of the properties that are to be modified. If this parameter is not provided,
all properties are modified. Those properties that are to be modified but have
no new values specified in the input instance get their default values.</p>

<p>The values of key properties cannot be modified.</p>

<blockquote><pre>>>> process0['Priority'] = Uint32(10);
>>> conn.ModifyInstance(process0, PropertyList=['Priority'])
>>> process0m = conn.GetInstance(process0.path)
>>> print process0m.items()
[...
 (u'Priority', 10L),
 ...]
</pre></blockquote>

<h3>CIM Method Operation</h3>

<p>CIM method invocations are quite easily done. The
<script>doc_link('method',
                 'pywbem.cim_operations.WBEMConnection.InvokeMethod',
                 'InvokeMethod()')</script>
method can be invoked on a CIM object that can be a CIM instance (referenced
via a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMInstanceName',
                 'CIMInstanceName')</script> object),
or a CIM class (for static methods only, referenced via its class name that
can be specified as a Python string, or as a
<script>doc_link('class',
                 'pywbem.cim_obj.CIMClassName',
                 'CIMClassName')</script> object).
The input parameters for the CIM method are simply specified as keyword
parameters to the Python method. The Python method returns a tuple of return
value, and a dictionary of the output parameters of the CIM method.</p>

<h3>CIM Association Operations</h3>

<p>PyWBEM supports all CIM operations related to association classes:</p>

<ul>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.Associators',
                       'Associators()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.AssociatorNames',
                       'AssociatorNames()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.References',
                       'References()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.ReferenceNames',
                       'ReferenceNames()')</script></li>
</ul>

<h3>CIM Class and Qualifier Operations</h3>

<p>PyWBEM supports all CIM operations to query, access and manipulate CIM
classes and qualifiers:</p>

<ul>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.EnumerateClassNames',
                       'EnumerateClassNames()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.EnumerateClasses',
                       'EnumerateClasses()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.GetClass',
                       'GetClass()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.DeleteClass',
                       'DeleteClass()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.ModifyClass',
                       'ModifyClass()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.CreateClass',
                       'CreateClass()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.EnumerateQualifiers',
                       'EnumerateQualifiers()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.GetQualifier',
                       'GetQualifier()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.SetQualifier',
                       'SetQualifier()')</script></li>
  <li><script>doc_link('method',
                       'pywbem.cim_operations.WBEMConnection.DeleteQualifier',
                       'DeleteQualifier()')</script></li>
</ul>

<h2>Further Examples</h2>

<p>To help get developers, testers and hackers started with the PyWBEM client
library, there is some further example code available to see how the basic
functions operate:</p>

<ul>
  <li><a href="pywbem/examples/00-connect.py">Making WBEM connections</a>
  <li><a href="pywbem/examples/01-enumerate-instances.py">Enumerate
      instances and instance names</a>
  <li><a href="pywbem/examples/02-getinstance.py">Get an instance by name</a>
  <li><a href="pywbem/examples/03-deleteinstance.py">Delete an instance</a>
  <li><a href="pywbem/examples/04-createinstance.py">Create an instance</a>
  <li><a href="pywbem/examples/05-modifyinstance.py">Modify an instance</a>
  <li><a href="pywbem/examples/06-invokemethod.py">Invoke a method</a>
</ul>

</div>

<div id="footer_html"></div>
<script type="text/javascript">
  load_url_into_id('footer.html', 'footer_html');
</script>
</body>
</html>
